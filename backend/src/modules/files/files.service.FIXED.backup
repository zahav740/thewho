/**
 * @file: files.service.ts
 * @description: –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–û: parseExcel)
 * @dependencies: fs, path
 * @created: 2025-01-28
 * @updated: 2025-06-09 // –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ Excel —Ñ–∞–π–ª–æ–≤
 */
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { promises as fs } from 'fs';
import { join } from 'path';
import * as ExcelJS from 'exceljs';
import { PDFDocument } from 'pdf-lib';
import type { Express } from 'express';

@Injectable()
export class FilesService {
  private readonly uploadsPath = join(process.cwd(), 'uploads');
  private readonly pdfPath = join(this.uploadsPath, 'pdf');
  private readonly excelPath = join(this.uploadsPath, 'excel');

  constructor() {
    this.ensureDirectories();
  }

  private async ensureDirectories() {
    const dirs = [this.uploadsPath, this.pdfPath, this.excelPath];
    for (const dir of dirs) {
      try {
        await fs.access(dir);
      } catch {
        await fs.mkdir(dir, { recursive: true });
      }
    }
  }

  async uploadFile(file: Express.Multer.File, folder: string = ''): Promise<string> {
    const targetPath = folder ? join(this.uploadsPath, folder) : this.uploadsPath;
    await fs.mkdir(targetPath, { recursive: true });
    
    const filename = `${Date.now()}-${file.originalname}`;
    const filepath = join(targetPath, filename);
    
    await fs.writeFile(filepath, file.buffer);
    
    return filename;
  }

  async getFile(filename: string, folder: string = ''): Promise<Buffer> {
    const filepath = folder 
      ? join(this.uploadsPath, folder, filename)
      : join(this.uploadsPath, filename);
    
    try {
      return await fs.readFile(filepath);
    } catch (error) {
      throw new NotFoundException('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
  }

  async deleteFile(filename: string, folder: string = ''): Promise<void> {
    const filepath = folder 
      ? join(this.uploadsPath, folder, filename)
      : join(this.uploadsPath, filename);
    
    try {
      await fs.unlink(filepath);
    } catch (error) {
      throw new NotFoundException('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
  }

  async parseExcel(file: Express.Multer.File): Promise<{
    headers: string[];
    rows: any[];
    sheetsCount: number;
  }> {
    console.log('üîç –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô parseExcel: –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞:', {
      originalname: file.originalname,
      size: file.size,
      mimetype: file.mimetype,
      hasBuffer: !!file.buffer,
      bufferSize: file.buffer?.length
    });

    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª –ø–µ—Ä–µ–¥–∞–Ω
      if (!file || !file.buffer) {
        console.error('‚ùå –§–∞–π–ª –∏–ª–∏ buffer –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç');
        throw new BadRequestException('–§–∞–π–ª –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω');
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
      if (file.buffer.length === 0) {
        console.error('‚ùå –ü—É—Å—Ç–æ–π —Ñ–∞–π–ª');
        throw new BadRequestException('–§–∞–π–ª –ø—É—Å—Ç–æ–π');
      }

      console.log('‚úÖ –§–∞–π–ª –ø—Ä–æ—à–µ–ª –±–∞–∑–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, –∑–∞–≥—Ä—É–∂–∞–µ–º —á–µ—Ä–µ–∑ ExcelJS...');

      const workbook = new ExcelJS.Workbook();
      
      try {
        await workbook.xlsx.load(file.buffer);
        console.log('‚úÖ Excel —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ ExcelJS');
      } catch (loadError) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Excel —á–µ—Ä–µ–∑ ExcelJS:', loadError);
        throw new BadRequestException(`–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è Excel —Ñ–∞–π–ª–∞: ${loadError.message}`);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç–æ–≤
      console.log(`üìÑ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—Å—Ç–æ–≤ –≤ —Ñ–∞–π–ª–µ: ${workbook.worksheets.length}`);
      
      if (workbook.worksheets.length === 0) {
        throw new BadRequestException('Excel —Ñ–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ä–∞–±–æ—á–∏—Ö –ª–∏—Å—Ç–æ–≤');
      }

      const worksheet = workbook.getWorksheet(1);
      if (!worksheet) {
        throw new BadRequestException('–ü–µ—Ä–≤—ã–π —Ä–∞–±–æ—á–∏–π –ª–∏—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
      }

      console.log('üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞–±–æ—á–µ–º –ª–∏—Å—Ç–µ:', {
        name: worksheet.name,
        rowCount: worksheet.rowCount,
        columnCount: worksheet.columnCount
      });

      const headers: string[] = [];
      const rows: any[] = [];

      try {
        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏–∑ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏
        const headerRow = worksheet.getRow(1);
        
        if (headerRow && headerRow.cellCount > 0) {
          console.log(`üìã –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∏–∑ ${headerRow.cellCount} —è—á–µ–µ–∫...`);
          
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–æ—Å–æ–± –ø–æ–ª—É—á–µ–Ω–∏—è —è—á–µ–µ–∫
          for (let colNum = 1; colNum <= Math.min(headerRow.cellCount, 50); colNum++) {
            try {
              const cell = headerRow.getCell(colNum);
              const cellValue = this.safeCellValue(cell);
              headers.push(cellValue || `–ö–æ–ª–æ–Ω–∫–∞ ${colNum}`);
            } catch (cellError) {
              console.warn(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —è—á–µ–π–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞ ${colNum}:`, cellError);
              headers.push(`–ö–æ–ª–æ–Ω–∫–∞ ${colNum}`);
            }
          }
          
          console.log('‚úÖ –ó–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª—É—á–µ–Ω—ã:', headers.slice(0, 10)); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 10
        } else {
          // –ï—Å–ª–∏ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –∏—Ö –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          console.log('‚ö†Ô∏è –ó–∞–≥–æ–ª–æ–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, —Å–æ–∑–¥–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏');
          for (let i = 1; i <= 10; i++) {
            headers.push(`–ö–æ–ª–æ–Ω–∫–∞ ${i}`);
          }
        }

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å—Ç—Ä–æ–∫
        let processedRows = 0;
        const maxRows = Math.min(worksheet.rowCount, 1000); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É 1000 —Å—Ç—Ä–æ–∫–∞–º–∏
        
        console.log(`üìä –ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É ${maxRows} —Å—Ç—Ä–æ–∫ –¥–∞–Ω–Ω—ã—Ö...`);

        for (let rowNum = 2; rowNum <= maxRows; rowNum++) {
          try {
            const row = worksheet.getRow(rowNum);
            
            if (!row || row.cellCount === 0) {
              continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            }

            const rowData: any = {};
            let hasData = false;

            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —è—á–µ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ
            for (let colNum = 1; colNum <= headers.length; colNum++) {
              try {
                const cell = row.getCell(colNum);
                const cellValue = this.safeCellValue(cell);
                const header = headers[colNum - 1];
                
                if (header && cellValue !== null && cellValue !== '') {
                  rowData[header] = cellValue;
                  hasData = true;
                }
              } catch (cellError) {
                console.warn(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —è—á–µ–π–∫–∏ [${rowNum},${colNum}]:`, cellError);
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –¥—Ä—É–≥–∏—Ö —è—á–µ–µ–∫
              }
            }

            if (hasData) {
              rows.push(rowData);
              processedRows++;
            }

            // –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 100 —Å—Ç—Ä–æ–∫
            if (processedRows % 100 === 0) {
              console.log(`üìà –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${processedRows} —Å—Ç—Ä–æ–∫...`);
            }

          } catch (rowError) {
            console.warn(`‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç—Ä–æ–∫–∏ ${rowNum}:`, rowError);
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ç—Ä–æ–∫
          }
        }

        console.log('‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô parseExcel: –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:', {
          headers: headers.length,
          rows: rows.length,
          sheetsCount: workbook.worksheets.length,
          processedRows
        });

        return {
          headers,
          rows,
          sheetsCount: workbook.worksheets.length,
        };

      } catch (processingError) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö Excel:', processingError);
        throw new BadRequestException(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö Excel: ${processingError.message}`);
      }

    } catch (error) {
      console.error('‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –æ—à–∏–±–∫–∞ –≤ parseExcel:', error);
      
      // –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ BadRequestException, –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
      if (error instanceof BadRequestException) {
        throw error;
      }
      
      // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ —Å–æ–∑–¥–∞–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      throw new BadRequestException(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å Excel —Ñ–∞–π–ª: ${error.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`);
    }
  }

  /**
   * –ò–°–ü–†–ê–í–õ–ï–ù–û: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ —è—á–µ–π–∫–∏ Excel
   */
  private safeCellValue(cell: ExcelJS.Cell): string | number | null {
    try {
      if (!cell) {
        return null;
      }

      const value = cell.value;
      
      if (value === null || value === undefined) {
        return null;
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∑–Ω–∞—á–µ–Ω–∏–π
      if (typeof value === 'string' || typeof value === 'number') {
        return value;
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–æ—Ä–º—É–ª—ã
      if (typeof value === 'object' && 'result' in value) {
        return value.result || null;
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞—Ç—ã
      if (value instanceof Date) {
        return value.toISOString().split('T')[0]; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–æ–≥–∞—Ç—ã–π —Ç–µ–∫—Å—Ç (rich text)
      if (typeof value === 'object' && 'richText' in value) {
        return value.richText?.map((rt: any) => rt.text).join('') || null;
      }

      // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤ –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ —Å—Ç—Ä–æ–∫—É
      return String(value);

    } catch (error) {
      console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è —è—á–µ–π–∫–∏:', error);
      return null;
    }
  }

  async generatePdfPreview(pdfBuffer: Buffer): Promise<string> {
    try {
      const pdfDoc = await PDFDocument.load(pdfBuffer);
      const pages = pdfDoc.getPages();
      
      if (pages.length === 0) {
        throw new BadRequestException('PDF —Ñ–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä–∞–Ω–∏—Ü');
      }

      // –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –ø—Ä–µ–≤—å—é
      const firstPage = pages[0];
      const { width, height } = firstPage.getSize();
      
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π PDF —Å —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ–π
      const previewDoc = await PDFDocument.create();
      const [copiedPage] = await previewDoc.copyPages(pdfDoc, [0]);
      previewDoc.addPage(copiedPage);
      
      const previewBytes = await previewDoc.save();
      const previewBase64 = Buffer.from(previewBytes).toString('base64');
      
      return `data:application/pdf;base64,${previewBase64}`;
    } catch (error) {
      throw new BadRequestException('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø—Ä–µ–≤—å—é PDF');
    }
  }

  async listFiles(folder: string = ''): Promise<{
    filename: string;
    size: number;
    createdAt: Date;
  }[]> {
    const targetPath = folder 
      ? join(this.uploadsPath, folder)
      : this.uploadsPath;
    
    try {
      const files = await fs.readdir(targetPath);
      const fileInfo = [];
      
      for (const file of files) {
        const filepath = join(targetPath, file);
        const stats = await fs.stat(filepath);
        
        if (stats.isFile()) {
          fileInfo.push({
            filename: file,
            size: stats.size,
            createdAt: stats.birthtime,
          });
        }
      }
      
      return fileInfo;
    } catch (error) {
      return [];
    }
  }

  async getFileInfo(filename: string, folder: string = '') {
    const filepath = folder 
      ? join(this.uploadsPath, folder, filename)
      : join(this.uploadsPath, filename);
    
    try {
      const stats = await fs.stat(filepath);
      return {
        filename,
        size: stats.size,
        createdAt: stats.birthtime,
        modifiedAt: stats.mtime,
        isFile: stats.isFile(),
        extension: filename.split('.').pop(),
      };
    } catch (error) {
      throw new NotFoundException('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
  }
}